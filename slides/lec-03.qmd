---
title: Data Engineering Fundamentals
subtitle: Lecture 3
author: Jan Kirenz
format:
  revealjs:
    theme: default
    transition: fade
    slide-number: true
    chalkboard:
      buttons: false
    preview-links: auto
    logo: images/logo.png
    css: slides.scss
    footer: MLOps | Jan Kirenz
    incremental: true 
#jupyter: python3
---



## Basics of Data Engineering

*How to collect, process, store, retrieve, and process data*


- Data storage

- Data format

- Data structure

- Data models
  - define how data stored 
  - in a particular data format 
  - is structured


## Data sources {background-color="#0ca37f"}

## Data Sources


- User input data
  - text, images, videos, uploaded files, etc.

- Internal databases (services and applications)
  - Inventory
  - Customer relationship
  - ... 

- System-generated data
  - Logs (tell you how the system is doing) 
  - System outputs (like model predictions)

- Third-party data

:::{.notes}
- Log everything you can (makes debugging easier)
   - What exactly?
   - How?
   - How long?
   - Privacy regulations?
:::

## Data Sources

- First-party data
  - Data that your company already collects about your users or customers S

- Second-party data 
  - Data collected by another company on their own customers that they make available to you, though you’ll probably have to pay for it
  
- Third-party data
  - Companies collect data on the public who aren’t their direct customers


## Data Formats {background-color="#0ca37f"}

## Data Formats 

- How do I store multimodal data, e.g., a sample that might contain both images and texts?

- Where do I store my data so that it’s cheap and still fast to access?

- How do I store complex models so that they can be loaded and run correctly on different hardware?

## Data Formats

- Store ("persist") data

- Data serialization
  - Converting data into a specific format

- Format depends on how data will be used 
  - Human readability
  - Access patterns
  - ...


## Some common data formats

| **Format** | **Binary/Text** | **Human-readable** | **Example** **use** **cases** |
| ---------- | --------------- | ------------------ | ----------------------------- |
| JSON       | Text            | Yes                | Everywhere                    |
| _CSV_      | _Text_          | _Yes_              | _Everywhere_                  |
| _Parquet_  | _Binary_        | _No_               | _Hadoop,_ _Amazon_ _Redshift_ |
| Avro       | Binary primary  | No                 | Hadoop                        |
| Protobuf   | Binary primary  | No                 | Google, TensorFlow (TFRecord) |
| Pickle     | Binary          | No                 | Python, PyTorch serialization |


## JSON

```JSON
{
"firstName": "Boatie",
"lastName": "McBoatFace",
"isVibing": true,
"age": 12,
"address": {
  "streetAddress": "12 Ocean Drive",
  "city": "Port Royal",
  "postalCode": "10021-3100"
}
}
```

 JSON (JavaScript Object Notation)
  - Human-readable
  - Key-value pair

## Row-Major Versus Column-Major Format

- CSV (comma-separated values) is row-major

- Parquet is column-major

![](images/lec-03/fig-3-1-row-column.png)

- Row-major formats
  - better when you have to do a lot of writes

- Column-major
  - better when you have to do a lot of column-based reads.

## NumPy vs pandas

- pandas: built around DataFrame
  - Column-major

- NumPy: 
  - Major order can be specified

![](images/lec-03/fig-3-2-pandas.png)


## Text vs Binary Format

  - **Text files**
    - Plain text
    - Human-readable
    - Not very efficient
    - E.g. CSV
  
  - **Binary format**
    - Nontext (only 0s and 1s)
    - Very compact
    - Not human-readable
    - E.g. Parquet files

## Text vs Binary Format

Store number `1000000`

- **Text file**
  - 7 characters 
  - Each character 1 byte
  - 7 byte
  
- **Binary file** (as int32)
  - 32 bits or 4 bytes

## Text vs Binary Format

- File with 17,654 rows and 10 columns
  - CSV: 14 MB
  - Parquet: 6 MB 

- Parquet format is up to 2x faster to unload and consumes up to 6x less storage in Amazon S3, compared to text formats

# Data models {background-color="#0ca37f"}

*Describe how data is represented*

## Relational Models

![](images/lec-03/fig-3-4-relational.png)

- Normalization
  - Reduces data redundancy 
  - Improves data integrity

## Relational Models {.smaller}

Initial book relation:

| Title | Author| Format | Publisher | Country | Price |
|--- | --- |  --- | --- | --- | --- |
| Harry Potter | J.K. Rowling | Paperback | Banana Press | UK | $20 |
| Harry Potter |J.K. Rowling | E-book  | Banana Press | UK | $10 |
| Sherlock Holmes | Conan Doyle | Paperback | Guava Press | US |$30 |
| The Hobbit | J.R.R. Tolkien | Paperback  | Banana Press | UK  | $30 |
| Sherlock Holmes | Conan Doyle | Paperback | Guava Press | US | $15 |

## Relational Models {.smaller}

Updated book relation:

| Title | Author| Format | Publisher ID  | Price |
| --- | --- |  --- | --- | --- | --- |
| Harry Potter | J.K. Rowling | Paperback | 1 | $20 |
| Harry Potter |J.K. Rowling | E-book  | 1  | $10 |
| Sherlock Holmes | Conan Doyle | Paperback | 2 |$30 |
| The Hobbit | J.R.R. Tolkien | Paperback  | 1  | $30 |
| Sherlock Holmes | Conan Doyle | Paperback | 2 | $15 |

<br>

| Publisher ID | Publisher | Country | 
| --- | --- |  --- | 
| 1 | Banana Press | UK |
| 1 | Guava Press | US |

- Downside: data is now spread across multiple relations

## Relational Models

- Relational databases 
  - PostgreSQL
  - MySQL

- Data needs to follow a strict schema

## Relational Models

Ranking of the most popular relational database management systems worldwide, as of January 2022:

![](images/lec-03/fig-ranking-databases.png)

Source: [Statista](https://www.statista.com/statistics/1131568/worldwide-popularity-ranking-relational-database-management-systems/)


## Relational Model

- Query language for relational databases

- Structured query language (SQL)
  - Declarative language

- SQL queries can become quite long and complex

## NoSQL

- Not only SQL

- Nonrelational models
  - Document model
  - 




